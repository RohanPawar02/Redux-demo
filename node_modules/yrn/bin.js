#!/usr/bin/env node
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var fs = require('fs');
var spawn = require('child_process').spawn;
var exec = require('child_process').exec;
var execSync = require('child_process').execSync;
var path = require('path');
var argv = require('yargs').argv;
var root = require('find-root')(process.cwd());
var parallel = require('run-parallel');
var jsonFile = require('jsonfile');

var pkgPath = root + '/package.json';
var originalPkg = require(pkgPath);
var hadYarnIntegrityFile = fs.existsSync(root + '/node_modules/.yarn-integrity');
var hadYarnLockFile = fs.existsSync(root + '/yarn.lock');

var modulePath = root + '/node_modules';
var symlinkPath = modulePath + '/.bin';
var oldModules = [];
var oldSymlinks = [];

if (argv._[0] === 'install' && !argv.g) {
  prepareArgsAndCallYarn();
} else callNpm();

function prepareArgsAndCallYarn() {
  var yarnArgs = [];
  var pkgNames = argv._.slice(1);

  if (argv.save) {
    pkgNames = [].concat(_toConsumableArray(pkgNames), [argv.save]);
  }
  if (argv.saveDev) {
    yarnArgs = ['--dev'];
    pkgNames = [].concat(_toConsumableArray(pkgNames), [argv.saveDev]);
  }
  yarnArgs = pkgNames.length > 0 ? ['add'].concat(_toConsumableArray(yarnArgs)) : ['install'];

  {
    var _path = root + '/node_modules';
    oldModules = fs.existsSync(_path) && getDirectories(_path);
    _path += '/.bin';
    oldSymlinks = fs.existsSync(_path) && fs.readdirSync(_path);
  }

  if (oldModules) execSync('mv ' + modulePath + ' ' + root + '/stash-node_modules');

  callYarn(yarnArgs, pkgNames, removePackages);

  function removePackages() {
    if (!argv.save && !argv.saveDev) {
      removeDependencies(pkgNames);
    }
    restorePackagesAndSymlinks(function (x) {
      if (!hadYarnLockFile) {
        fs.unlink(root + '/yarn.lock');
      }
      if (!hadYarnIntegrityFile) {
        exec('rm -rf ' + root + '/node_modules/.yarn-integrity');
      }
      exec('rm -rf ' + root + '/stash-node_modules');
    });
  }
}

function getDirectories(dir) {
  return fs.readdirSync(dir).filter(function (file) {
    return fs.statSync(path.join(dir, file)).isDirectory();
  });
}

function callNpm() {
  var out$ = spawn('npm', process.argv.slice(2));
  out$.stdout.pipe(process.stdout);
  out$.stderr.pipe(process.stderr);
}

function callYarn(yarnArgs, pkgNames, cb) {
  var out$ = spawn('yarn', [].concat(_toConsumableArray(yarnArgs), _toConsumableArray(pkgNames)));
  out$.on('exit', cb);
  out$.stdout.pipe(process.stdout);
  out$.stderr.pipe(process.stderr);
}

function removeDependencies(pkgNames) {
  if (!fs.existsSync(pkgPath)) return;
  var newPkg = jsonFile.readFileSync(pkgPath);

  pkgNames.forEach(function (pkgName) {
    if (!argv.save) {
      if (originalPkg.dependencies && !originalPkg.dependencies[pkgName]) {
        delete newPkg.dependencies[pkgName];
      }
    }
    if (!argv.saveDev) {
      if (originalPkg.devDependencies && !originalPkg.devDependencies[pkgName]) {
        delete newPkg.devDependencies[pkgName];
      }
    }
  });
  jsonFile.writeFileSync(pkgPath, newPkg, { spaces: 2 });
}

function restorePackagesAndSymlinks(cb) {
  var calls = [];

  if (oldModules) {
    var newModules = getDirectories(modulePath);
    pushCalls(newModules, oldModules, './');
  }
  if (oldSymlinks) {
    var newSymlinks = fs.readdirSync(symlinkPath);
    pushCalls(newSymlinks, oldSymlinks, '.bin/');
  }

  parallel(calls, cb);

  function pushCalls(newItems, oldItems, dir) {
    var toBeRestored = findItemsToRestore(newItems, oldItems);
    var stashedModulesPath = root + '/stash-node_modules/' + dir;
    toBeRestored.forEach(function (name) {
      return calls.push(function (done) {
        exec('mv ' + stashedModulesPath + name + ' ' + modulePath, {}, done);
      });
    });
  }
  function findItemsToRestore(newItems, oldItems) {
    newItems.forEach(function (moduleName) {
      var i = oldItems.indexOf(moduleName);
      if (i !== -1) oldItems.splice(i, 1);
    });
    return oldItems;
  }
}
